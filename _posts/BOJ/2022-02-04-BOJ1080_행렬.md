---
title: "[BOJ] 행렬(1080)"
tags: 
    - BOJ

key: "[BOJ] 행렬(1080)"
---

## 문제

[BOJ_1080 행렬](https://www.acmicpc.net/problem/1080)<br>

<!--more-->

## 문제 이해

이 문제는 두개의 행렬이 주어지는데 하나의 행렬을 3x3크기의 부분 행렬로 뒤집어서 두 행렬을 같도록 만드는 것이다. 뒤집을때는 3x3크기의 모든 원소를 다 뒤집어야 한다. ( 0 → 1, 1 → 0)

## 문제 해결

이 문제를 해결하기 위해서는 먼저 두 행렬을 비교해서 같은 부분과 같지 않은 부분을 0, 1로 표현한 행렬을 만들어야 한다. 

예를들면,

```
3 4
0000
0010
0000
1001
1011
1001
```

- 3x4크기의 행렬 두개(입력값)

```

1001
1001
1001

```

- 두 행렬을 비교해서 같은 부분과 다른 부분을 표현한 행렬

이런식으로 행렬을 표현할 수 있다.

두개를 비교한 행렬에서 첫번째 원소가 1이고 3x3크기의 부분행렬을 뒤집을 수 있으므로 뒤집을 수 있고 이렇게 계속 반복하게 되면 마지막 처럼 결과가 나올 수 있고 2번 뒤집는게 정답이 된다.

```
0111
0111
0111
```

→

```
0111
0111
0111
```

→

```
0111
0111
0111
```

→

```
0000
0000
0000
```

하지만 여기서 주의할 점이 있다.

1. 이미 두 행렬이 같은경우 3x3 부분행렬을 사용할 수 없는 경우에도 -1이 아닌 0이 결과로 출력되어야한다.
2.  입력값이 0000같이 붙어서 입력되므로 scanf(”%1d”,xx)를 사용해야되므로 ios_base를 사용하면 안된다.
3. 바꿔야 하는 원소(1인 원소)가 있는데 3x3크기의 범위를 벗어나서 뒤집을 수 없는경우 -1(바꿀수 없음)을 출력해야한다.

## 코드

```cpp
//행렬
// int 변수 1과 0을 비트연산 &을 하게되면 0001 & 0000 => 0000
// 반대로 바꾸기 위해서는 xor연산을 해야한다.
// 반례에서 막혔다 + ios_base를 사용하면 scanf를 사용하면 안된다. 
#include <bits/stdc++.h>
using namespace std;

int arr[50][50];
int N,M,cnt;

int main(){
    cin >> N >> M;
    for(int i = 0; i < N; ++i)
        for(int j = 0; j < M; ++j)
            scanf("%1d",&arr[i][j]);

    for(int i = 0; i < N; ++i)
        for(int j = 0; j < M; ++j){
           int tmp; scanf("%1d", &tmp);
           arr[i][j] ^= tmp; //기존 행렬과 다른 경우 1 같은경우 0
        }  
    
    for(int i = 0; i < N; ++i)
        for(int j = 0; j < M; ++j){
            if(arr[i][j]){
                //바꿔야 하지만 범위가 넘어가는 경우 안된다고 판단
                if(i + 2 >= N || j + 2 >= M){
                    cout << -1;
                    return 0;
                }

                for(int k = i; k < i + 3; ++k){
                    arr[k][j] ^= 1;
                    arr[k][j+1] ^= 1;
                    arr[k][j+2] ^= 1;
                }

                cnt++;
            }
        }

    cout << cnt;
    return 0;
}
```