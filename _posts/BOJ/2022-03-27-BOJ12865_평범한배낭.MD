---
title: "[BOJ] 평범한 배낭(12865)"
tags: 
    - BOJ

key: "[BOJ] 평범한 배낭(12865)"
---

## 문제

[BOJ_12865 평범한 배낭](https://www.acmicpc.net/problem/12865)<br>

<!--more-->

## 문제 이해

가방에 넣을 수 있는 최대 무게(K)가 주어지고 N개의 물건이 주어진다.

각각의 물건은 무게와 가치가 주어지는데 제한된 가방의 무게에서 가장 가치가 높게 물건을 담는 것이 문제의 핵심이다.

이 문제는 전형적인 배낭 문제라고 한다. 짐을 쪼갤 수 있는 경우는 그리디하게 풀고 짐을 쪼갤 수 없는 경우는 dp로 풀면 된다.

이문제는 짐을 쪼갤 수 없으므로 dp로 문제를 해결해야 한다.

## 문제 풀이

w[i]는 i번째 물건의 무게 v[i]는 i번째 물건의 가치를 뜻하고 dp[i][j]는 i번째 물건들 중에서 j무게까지 넣을 수 있을때의 최대 가치를 의미한다.

먼저 물건의 무게가 j를 넘는지 확인하고 넘지 않으면 이전 dp[i-1][j]의 가치와 dp[i-1][j-w[i]] + v[i]의 가치를 비교해 더 큰 가치가 dp[i][j]의 가치가 된다.

만약 물건의 무게가 j를 넘으면 dp[i-1][j]의 가치가 dp[i][j]의 가치가 된다.



## 코드

```cpp
#include <iostream>

using namespace std;

int N, K, w[101],v[101], dp[101][100001];

int main(){
    cin >> N >> K;

    for(int i = 1; i <= N; ++i){
        cin >> w[i] >> v[i];
    }

    for(int i = 1; i <= N; ++i){
        for(int j = 1; j <= K; ++j){
            if(w[i] <= j){
                dp[i][j] = max(dp[i-1][j],dp[i-1][j - w[i]] + v[i]);
            }
            else{
                dp[i][j] = dp[i-1][j];
            }
        }
    }

    cout << dp[N][K];
}

```